//--------------------------------------
//--- 010 Editor v4.0.1 Binary Template
//
// File: CAPTemplate.bt
// Author: Andrew McRae
// Revision: 0.1
// Purpose: UEFI Cap firmware file
//--------------------------------------

typedef ubyte UINT8;
typedef byte INT8;

typedef struct {
    UINT32 Data1;
    UINT16 Data2;
    UINT16 Data3;
    BigEndian();
    UINT64 Data4;
    LittleEndian();
} GUID <read=read_GUID>;

string read_GUID(GUID &in) {
    local string out;
    local UINT32 d1 = in.Data1;
    local UINT32 d2 = in.Data2;
    local UINT32 d3 = in.Data3;
    local UINT64 d4 = in.Data4;
    local UINT32 d4a = d4 >> 32;
    local UINT32 d4b = d4 & 0xFFFFFFFF;
         if (d1 == 0x3b6686bd && d2 == 0x0d76 && d3 == 0x4030 && d4a == 0xb70eb551 && d4b == 0x9e2fc5a0) {
        out = "EFI_CAPSULE_GUID";
    }
    else if (d1 == 0x4a3ca68b && d2 == 0x7723 && d3 == 0x48fb && d4a == 0x803d578c && d4b == 0xc1fec44d) {
        out = "EFI_SIGNED_CAPSULE_GUID";
    }
    else if (d1 == 0xa7717414 && d2 == 0xc616 && d3 == 0x4977 && d4a == 0x94208447 && d4b == 0x12a735bf) {
        out = "EFI_CERT_TYPE_RSA2048_SHA256_GUID";
    }
    else if (d1 == 0x4aafd29d && d2 == 0x68df && d3 == 0x49ee && d4a == 0x8aa9347d && d4b == 0x375665a7) {
        out = "EFI_CERT_TYPE_PKCS7_GUID";
    }
    else if (d1 == 0x51aa59de && d2 == 0xfdf2 && d3 == 0x4ea3 && d4a == 0xbc63875f && d4b == 0xb7842ee9) {
        out = "EFI_HASH_ALGORITHM_SHA256_GUID";
    }
    else {
        SPrintf(out, "{%08X-%04X-%04X-%04X-%04X%08X}",
            d1, d2, d3, d4a >> 16, d4a & 0xFFFF, d4b);
    }
    return out;
}

typedef struct {
    UINT32 Offset;

    if (Offset) {
        local quad pos = FTell();
        FSeek(Offset);
        SetBackColor(0xc0c0ff);
        while (ReadShort(FTell())) {
            wstring name;
        }
        SetBackColor(0xb0b0e0);
        UINT16 end;
        FSeek(pos);
    }
} EFI_STRING_OFFSET <read=read_EFI_STRING_OFFSET>;

string read_EFI_STRING_OFFSET(EFI_STRING_OFFSET &in) {
    if (in.Offset) {
        return WStringToUTF8(in.name);
    }
    else {
        return "";
    }
}

typedef struct {
    local UINT32 value = ReadUInt(FTell());
    BitfieldDisablePadding();

// 0x00000001
int EFI_CAPSULE_HEADER_FLAG_SETUP: 1;

int CAPSULE_FLAGS_res1: 15 <hidden=true>;

// 0x00010000
int CAPSULE_FLAGS_PERSIST_ACROSS_RESET: 1;

// 0x00020000
int CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE: 1;

int CAPSULE_FLAGS_res2: 14 <hidden=true>;

    BitfieldEnablePadding();
} EFI_CAPSULE_HEADER_FLAGS <read=read_EFI_CAPSULE_HEADER_FLAGS>;

string read_EFI_CAPSULE_HEADER_FLAGS(EFI_CAPSULE_HEADER_FLAGS &in) {
    local string out;
    SPrintf(out, "%Xh", in.value);
    return out;
}

typedef struct {
    GUID OemGuid;
    UINT32 HeaderSize;

    if (HeaderSize > (16 + 4)) {
        SetBackColor(0xe0b0b0);
        UINT8 Data[HeaderSize - (16 + 4)];
    }
} EFI_CAPSULE_OEM_HEADER;

typedef struct {
    GUID HashType;
    UINT8 PublicKey[256];
    UINT8 Signature[256];
} EFI_CERT_TYPE_RSA2048_SHA256;

typedef struct {
    UINT32 dwLength;
    UINT16 wRevision;
    enum <UINT16> {
WIN_CERT_TYPE_PKCS_SIGNED_DATA = 0x002,
WIN_CERT_TYPE_EFI_PKCS115 = 0x0EF0,
WIN_CERT_TYPE_EFI_GUID = 0xEF1
    } wCertificateType;

    if (wCertificateType == WIN_CERT_TYPE_EFI_GUID) {
        GUID CertType;
        if (read_GUID(CertType) == "EFI_CERT_TYPE_RSA2048_SHA256_GUID") {
            EFI_CERT_TYPE_RSA2048_SHA256 Cert;
        }
    }
} WIN_CERTIFICATE;

typedef struct {
    GUID CapsuleGuid;
    UINT32 HeaderSize;
    Assert(HeaderSize == 0x1c || HeaderSize == 0x50, "Unknown HeaderSize");
    EFI_CAPSULE_HEADER_FLAGS Flags;
    UINT32 CapsuleImageSize;
    //Assert(CapsuleImageSize == FileSize(), "Invalid CapsuleImageSize");
    if (HeaderSize == 0x50) {
        UINT32 SequenceNumber;
        GUID InstanceId;
        UINT32 OffsetToSplitInformation;
        UINT32 OffsetToCapsuleBody;
        UINT32 OffsetToOemDefinedHeader;
        EFI_STRING_OFFSET OffsetToAuthorInformation;
        EFI_STRING_OFFSET OffsetToRevisionInformation;
        EFI_STRING_OFFSET OffsetToShortDescription;
        EFI_STRING_OFFSET OffsetToLongDescription;
        UINT32 OffsetToApplicableDevices;

        if (OffsetToOemDefinedHeader) {
            FSeek(OffsetToOemDefinedHeader);
            SetBackColor(0xffc0c0);
            EFI_CAPSULE_OEM_HEADER oh;
        }
    }
    else if (read_GUID(CapsuleGuid) == "EFI_SIGNED_CAPSULE_GUID") {
        UINT16 OffsetToCapsuleBody;
        UINT16 OffsetToOemDefinedHeader;

        SetBackColor(0xc0ffc0);
        WIN_CERTIFICATE c;
        EFI_CERT_TYPE_RSA2048_SHA256 c2;

        if (OffsetToOemDefinedHeader) {
            FSeek(OffsetToOemDefinedHeader);
            SetBackColor(0xffc0c0);
            UINT8 oh[OffsetToCapsuleBody - OffsetToOemDefinedHeader];
        }
    }
    else {
        local UINT32 OffsetToCapsuleBody = 0;
    }
} EFI_CAPSULE_HEADER <read=read_EFI_CAPSULE_HEADER>;

string read_EFI_CAPSULE_HEADER(EFI_CAPSULE_HEADER &in) {
    return read_GUID(in.CapsuleGuid);
}

DisplayFormatHex();
LittleEndian();

SetBackColor(0xe0e0e0);
EFI_CAPSULE_HEADER h;

if (h.OffsetToCapsuleBody) {
    FSeek(h.OffsetToCapsuleBody);
}

SetBackColor(0xa0a0a0);
UINT8 data[h.CapsuleImageSize - FTell()];
