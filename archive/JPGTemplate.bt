//          010 Editor v2.02 Binary Template
//
// File		: JpgTemplate.bt
// Author	: Mor FTP
// Purpose	: Designed for jpg files
// E-Mail	: morftp AT hotmail DOT com
// LAST MODIFIED : Aug 19 2005 
// This is a detailed JPEG File analysis. 
//Features 
//  1. Huffmann and quantization tables.
//  2. Exif (APP1) information including jpeg and other thubnail images
//  3. SOS, SOF0, JIFF and APP0 sections
//
// Note : This code doesn't parse all known sections. The reson is the application sections
//  contain camera specific information and this information sometimes is not public or 
//  related to the camera and not important for image display softwares.
//
// New Features: Parses MakerNote for casio qv-r62 
//
//
//--------------------------------------

BigEndian();
local quad JpegFileSize = 100;
local quad JpegFileOffset = 0;
local int colorId = 0; 
local int colorSelect = 0; 
local DWORD clr = 0;
local DWORD jetMap[6*3] = { // blue, red green
	0x0000cc,0x0000ff,0x0033ff,0x0066ff,0x0099ff,0x00ccff,
		0x00ffff,0x33ffcc,0x66ff99,0x99ff66,0xccff33,0xffff00,
		0xffcc00,0xff9900,0xff6600,0xff3300,0xff0000,0xcc0000
};
local char CameraMake[32];
local char CameraModel[40];
local char lalign;
local char isMakerNote = 0; //If processing maker note, it is 1 for casio qv-r62

void ChangeColor(byte bChangeColor){
	if(bChangeColor == 1) {colorSelect++; colorId = 0;}
	clr = jetMap[(colorSelect%3)*6+(colorId%6)]; 
	SetBackColor(clr);
	//Printf("clrIdx = [%d %d], RGB(%d,%d,%d)\n",colorSelect,colorId,(clr>>16),(clr>>8)&0x00FF,clr&0x0000FF);
	colorId++;
}

typedef enum <WORD> tagID
{
	M_SOF0  = 0xFFC0, // Start Of Frame N
		M_SOF1,// N indicates which compression process
		M_SOF2,// Only SOF0-SOF2 are now in common use
		M_SOF3,
		M_DHT, //Huffman Table 
		M_SOF5,    
		M_SOF6,
		M_SOF7,
		M_SOF8,
		M_SOF9,
		M_SOF10,
		M_SOF11,
		M_SOF12,
		M_SOF13,
		M_SOF14,
		M_SOF15,
		M_SOI = 0xFFD8, // Start Of Image 
		M_EOI,// End Of Image 
		M_SOS,// Start Of Scan (begins compressed data)
		M_DQT,
		M_APP0 = 0xFFE0, // Jfif marker
		M_APP1,// Exif marker
		M_APP2,
		M_APP3,
		M_APP4,
		M_APP5,
		M_APP6,
		M_APP7,
		M_APP8,
		M_APP9,
		M_APP10,
		M_APP11,
		M_APP12,
		M_APP13,
		M_APP14,
		M_APP15,
		M_COMM = 0xFFFE  // Comment 
}M_ID; 
typedef enum <WORD> tagCasioTag2{
  	PreviewThumbnailDimensions	=   0x0002,//Numeric  	 2 values - x,y dimensions in pixels
	PreviewThumbnailSize		=	0x0003,//Numeric 	Size in bytes
	PreviewThumbnailOffset 		=	0x0004,//Numeric 	Offset of Preview Thumbnail
	CSQualityMode					=	0x0008,//Numeric Lookup	1 = Fine 2 = Super Fine 
	CsImageSize					=	0x0009,//Numeric Lookup 	0 = 640 x 480 pixels 4 = 1600 x 1200 pixels 5 = 2048 x 1536 pixels 20 = 2288 x 1712 pixels 21 = 2592 x 1944 pixels 22 = 2304 x 1728 pixels 36 = 3008 x 2008 pixels 
	CSFocusMode 					=	0x000D,//Numeric Lookup 	0 = Normal 1 = Macro 
	CsIsoSensitivity 			=	0x0014,//Numeric Lookup 	3 = 50 4 = 64 6 = 100 9 = 200 
	CsWhiteBalance 				=	0x0019,//Numeric Lookup 	0 = Auto 1 = Daylight 2 = Shade 3 = Tungsten 4 = Fluorescent 5 = Manual 
	CsFocalLength					=	0x001D,//Numeric 	Units are tenths of a millimetre
	CsSaturation					=   0x001F,//Numeric Lookup 	0 = -1 1 = Normal 2 = +1 
	CsContrast					=	0x0020,//Numeric Lookup 	0 = -1 1 = Normal 2 = +1 
	CsSharpness 					=	0x0021,//Numeric Lookup 	0 = -1 1 = Normal 2 = +1
	CsPrintImageMatchingInfo 		=	0x0E00,//PIM 	See Print Image Matching for specification
	CasioPreviewThumbnail 		=	0x2000,//Numeric 	Alternate thumbnail offset
 	CsWhiteBalanceBias 			=	0x2011,//Numeric 	 
	CsFlashMode 						=   0x2012,//Numeric Lookup 	12 = Flash 0 = Manual 1 = Auto? 4 = Flash? 
	CsObjectDistance 				=	0x2022,//Numeric 	Units are millimetres
	CsFlashDistance 				=	0x2034,//Numeric 	0 = Off
	CsRecordMode 					=	0x3000,//Numeric Lookup 	2 = Normal Mode 
	CsSelfTimer					=	0x3001,//Numeric Lookup 	1 = Off? 
	CsQuality 					=	0x3002,//Numeric Lookup 	3 = Fine
 	CsMeteringMode2				=	0x3003,//Numeric Lookup 	1 = Fixation 6 = Multi-Area Auto Focus
	CsTimeZone 					=	0x3006,//String 	 
	CsBestshotMode 				=	0x3007,//Numeric Lookup 	0 = Off 1 = On?
	CsCCDISOSensitivity 			=	0x3014 ,//Numeric 	 
	CsColourMode 					=	0x3015 ,//Numeric Lookup 	0 = Off
 	CsEnhancement 				=	0x3016,//Numeric Lookup 	0 = Off
	CsFilter 						=	0x3017,//Numeric Lookup 	0 = Off
}CasioTag2;

typedef enum <WORD> tagExifTag{
	///////////////////////////////////			Format            Comp  Description	
	InteropIndex               = 0x0001,
		InteropVersion             = 0x0002,
		SubfileType                = 0x00fe,
		OldSubfileType             = 0x00ff,
		ImageWidth                 = 0x0100,
		ImageHeight                = 0x0101,
		BitsPerSample              = 0x0102,
		Compression                = 0x0103,
		PhotometricInterpretation  = 0x0106,
		Thresholding               = 0x0107,
		CellWidth                  = 0x0108,
		CellLength                 = 0x0109,
		FillOrder                  = 0x010a,
		DocumentName               = 0x010d,
		ImageDescription           = 0x010e,
		Make                       = 0x010f,
		Model                      = 0x0110,
		StripOffsets               = 0x0111,
		Orientation                = 0x0112,
		SamplesPerPixel            = 0x0115,
		RowsPerStrip               = 0x0116,
		StripByteCounts            = 0x0117,
		MinSampleValue             = 0x0118,
		MaxSampleValue             = 0x0119,
		XResolution                = 0x011a,
		YResolution                = 0x011b,
		PlanarConfiguration        = 0x011c,
		PageName                   = 0x011d,
		XPosition                  = 0x011e,
		YPosition                  = 0x011f,
		FreeOffsets                = 0x0120,
		FreeByteCounts             = 0x0121,
		GrayResponseUnit           = 0x0122,
		GrayResponseCurve          = 0x0123,
		T4Options                  = 0x0124,
		T6Options                  = 0x0125,
		ResolutionUnit             = 0x0128,
		PageNumber                 = 0x0129,
		ColorResponseUnit          = 0x012c,
		TransferFunction           = 0x012d,
		Software                   = 0x0131,
		ModifyDate                 = 0x0132,
		Artist                     = 0x013b,
		HostComputer               = 0x013c,
		Predictor                  = 0x013d,
		WhitePoint                 = 0x013e,
		PrimaryChromaticities      = 0x013f,
		ColorMap                   = 0x0140,
		HalftoneHints              = 0x0141,
		TileWidth                  = 0x0142,
		TileLength                 = 0x0143,
		TileOffsets                = 0x0144,
		TileByteCounts             = 0x0145,
		BadFaxLines                = 0x0146,
		CleanFaxData               = 0x0147,
		ConsecutiveBadFaxLines     = 0x0148,
		SubIFD                     = 0x014a,
		InkSet                     = 0x014c,
		InkNames                   = 0x014d,
		NumberofInks               = 0x014e,
		DotRange                   = 0x0150,
		TargetPrinter              = 0x0151,
		ExtraSamples               = 0x0152,
		SampleFormat               = 0x0153,
		SMinSampleValue            = 0x0154,
		SMaxSampleValue            = 0x0155,
		TransferRange              = 0x0156,
		ClipPath                   = 0x0157,
		XClipPathUnits             = 0x0158,
		YClipPathUnits             = 0x0159,
		Indexed                    = 0x015a,
		JPEGTables                 = 0x015b,
		OPIProxy                   = 0x015f,
		GlobalParametersIFD        = 0x0190,
		ProfileType                = 0x0191,
		FaxProfile                 = 0x0192,
		CodingMethods              = 0x0193,
		VersionYear                = 0x0194,
		ModeNumber                 = 0x0195,
		Decode                     = 0x01b1,
		DefaultImageColor          = 0x01b2,
		JPEGProc                   = 0x0200,
		ThumbnailOffset            = 0x0201,
		ThumbnailLength            = 0x0202,
		JPEGRestartInterval        = 0x0203,
		JPEGLosslessPredictors     = 0x0205,
		JPEGPointTransforms        = 0x0206,
		JPEGQTables                = 0x0207,
		JPEGDCTables               = 0x0208,
		JPEGACTables               = 0x0209,
		YCbCrCoefficients          = 0x0211,
		YCbCrSubSampling           = 0x0212,
		YCbCrPositioning           = 0x0213,
		ReferenceBlackWhite        = 0x0214,
		StripRowCounts             = 0x022f,
		ApplicationNotes           = 0x02bc,
		RelatedImageFileFormat     = 0x1000,
		RelatedImageWidth          = 0x1001,
		RelatedImageLength         = 0x1002,
		ImageID                    = 0x800d,
		WangAnnotation             = 0x80a4,
		Matteing                   = 0x80e3,
		DataType                   = 0x80e4,
		ImageDepth                 = 0x80e5,
		TileDepth                  = 0x80e6,
		Model2                     = 0x827d,
		CFARepeatPatternDim        = 0x828d,
		CFAPattern2                = 0x828e,
		BatteryLevel               = 0x828f,
		Copyright                  = 0x8298,
		ExposureTime               = 0x829a,
		FNumber                    = 0x829d,
		PixelScale                 = 0x830e,
		IPTC_NAA                   = 0x83bb,
		IntergraphPacketData       = 0x8474,
		IntergraphFlagRegisters    = 0x847f,
		IntergraphMatrix           = 0x8480,
		ModelTiePoint              = 0x8482,
		Site                       = 0x84e0,
		ColorSequence              = 0x84e1,
		IT8Header                  = 0x84e2,
		RasterPadding              = 0x84e3,
		BitsPerRunLength           = 0x84e4,
		BitsPerExtendedRunLength   = 0x84e5,
		ColorTable                 = 0x84e6,
		ImageColorIndicator        = 0x84e7,
		BackgroundColorIndicator   = 0x84e8,
		ImageColorValue            = 0x84e9,
		BackgroundColorValue       = 0x84ea,
		PixelIntensityRange        = 0x84eb,
		TransparencyIndicator      = 0x84ec,
		ColorCharacterization      = 0x84ed,
		HCUsage                    = 0x84ee,
		IPTC_NAA2                  = 0x8568,
		ModelTransform             = 0x85d8,
		PhotoshopSettings          = 0x8649,
		ExifOffset                 = 0x8769,
		ICC_Profile                = 0x8773,
		ImageLayer                 = 0x87ac,
		GeoTiffDirectory           = 0x87af,
		GeoTiffDoubleParams        = 0x87b0,
		GeoTiffAsciiParams         = 0x87b1,
		ExposureProgram            = 0x8822,
		SpectralSensitivity        = 0x8824,
		GPSInfo                    = 0x8825,
		ISO                        = 0x8827,
		OptoElectricConvFactor     = 0x8828,
		Interlace                  = 0x8829,
		TimeZoneOffset             = 0x882a,
		SelfTimerMode              = 0x882b,
		FaxRecvParams              = 0x885c,
		FaxSubAddress              = 0x885d,
		FaxRecvTime                = 0x885e,
		ExifVersion                = 0x9000,
		DateTimeOriginal           = 0x9003,
		CreateDate                 = 0x9004,
		ComponentsConfiguration    = 0x9101,
		CompressedBitsPerPixel     = 0x9102,
		ShutterSpeedValue          = 0x9201,
		ApertureValue              = 0x9202,
		BrightnessValue            = 0x9203,
		ExposureCompensation       = 0x9204,
		MaxApertureValue           = 0x9205,
		SubjectDistance            = 0x9206,
		MeteringMode               = 0x9207,
		LightSource                = 0x9208,
		Flash                      = 0x9209,
		FocalLength                = 0x920a,
		FlashEnergy                = 0x920b,
		SpatialFrequencyResponse   = 0x920c,
		Noise                      = 0x920d,
		FocalPlaneXResolution      = 0x920e,
		FocalPlaneYResolution      = 0x920f,
		FocalPlaneResolutionUnit   = 0x9210,
		ImageNumber                = 0x9211,
		SecurityClassification     = 0x9212,
		ImageHistory               = 0x9213,
		SubjectLocation            = 0x9214,
		ExposureIndex              = 0x9215,
		TIFF_EPStandardID          = 0x9216,
		SensingMethod              = 0x9217,
		StoNits                    = 0x923f,
		MakerNote                  = 0x927c,
		UserComment                = 0x9286,
		SubSecTime                 = 0x9290,
		SubSecTimeOriginal         = 0x9291,
		SubSecTimeDigitized        = 0x9292,
		ImageSourceData            = 0x935c,
		XPTitle                    = 0x9c9b,
		XPComment                  = 0x9c9c,
		XPAuthor                   = 0x9c9d,
		XPKeywords                 = 0x9c9e,
		XPSubject                  = 0x9c9f,
		FlashpixVersion            = 0xa000,
		ColorSpace                 = 0xa001,
		ExifImageWidth             = 0xa002,
		ExifImageLength            = 0xa003,
		RelatedSoundFile           = 0xa004,
		InteropOffset              = 0xa005,
		FlashEnergy2               = 0xa20b,
		SpatialFrequencyResponse2  = 0xa20c,
		Noise2                     = 0xa20d,
		FocalPlaneXResolution2     = 0xa20e,
		FocalPlaneYResolution2     = 0xa20f,
		FocalPlaneResolutionUnit2  = 0xa210,
		ImageNumber2               = 0xa211,
		SecurityClassification2    = 0xa212,
		ImageHistory2              = 0xa213,
		SubjectLocation2           = 0xa214,
		ExposureIndex2             = 0xa215,
		TIFF_EPStandardID2         = 0xa216,
		SensingMethod2             = 0xa217,
		FileSource                 = 0xa300,
		SceneType                  = 0xa301,
		CFAPattern                 = 0xa302,
		CustomRendered             = 0xa401,
		ExposureMode               = 0xa402,
		WhiteBalance               = 0xa403,
		DigitalZoomRatio           = 0xa404,
		FocalLengthIn35mmFormat    = 0xa405,
		SceneCaptureType           = 0xa406,
		GainControl                = 0xa407,
		Contrast                   = 0xa408,
		Saturation                 = 0xa409,
		Sharpness                  = 0xa40a,
		DeviceSettingDescription   = 0xa40b,
		SubjectDistanceRange       = 0xa40c,
		ImageUniqueID              = 0xa420,
		GDALMetadata               = 0xa480,
		GDALNoData                 = 0xa481,
		Gamma                      = 0xa500,
		FilmProductCode            = 0xc350,
		ImageSourceEK              = 0xc351,
		CaptureConditionsPAR       = 0xc352,
		CameraOwner                = 0xc353,
		SerialNumber               = 0xc354,
		UserSelectGroupTitle       = 0xc355,
		DealerIDNumber             = 0xc356,
		CaptureDeviceFID           = 0xc357,
		EnvelopeNumber             = 0xc358,
		FrameNumber                = 0xc359,
		FilmCategory               = 0xc35a,
		FilmGencode                = 0xc35b,
		ModelAndVersion            = 0xc35c,
		FilmSize                   = 0xc35d,
		SBA_RGBShifts              = 0xc35e,
		SBAInputImageColorspace    = 0xc35f,
		SBAInputImageBitDepth      = 0xc360,
		SBAExposureRecord          = 0xc361,
		UserAdjSBA_RGBShifts       = 0xc362,
		ImageRotationStatus        = 0xc363,
		RollGuidElements           = 0xc364,
		MetadataNumber             = 0xc365,
		EditTagArray               = 0xc366,
		Magnification              = 0xc367,
		NativeXResolution          = 0xc36c,
		NativeYResolution          = 0xc36d,
		KodakEffectsIFD            = 0xc36e,
		KodakBordersIFD            = 0xc36f,
		NativeResolutionUnit       = 0xc37a,
		SourceImageDirectory       = 0xc418,
		SourceImageFileName        = 0xc419,
		SourceImageVolumeName      = 0xc41a,
		OceScanjobDesc             = 0xc427,
		OceApplicationSelector     = 0xc428,
		OceIDNumber                = 0xc429,
		OceImageLogic              = 0xc42a,
		Annotations                = 0xc44f,
		PrintQuality               = 0xc46c,
		ImagePrintStatus           = 0xc46e,
		PrintIM                    = 0xc4a5,
		DNGVersion                 = 0xc612,
		DNGBackwardVersion         = 0xc613,
		UniqueCameraModel          = 0xc614,
		LocalizedCameraModel       = 0xc615,
		CFAPlaneColor              = 0xc616,
		CFALayout                  = 0xc617,
		LinearizationTable         = 0xc618,
		BlackLevelRepeatDim        = 0xc619,
		BlackLevel                 = 0xc61a,
		BlackLevelDeltaH           = 0xc61b,
		BlackLevelDeltaV           = 0xc61c,
		WhiteLevel                 = 0xc61d,
		DefaultScale               = 0xc61e,
		DefaultCropOrigin          = 0xc61f,
		DefaultCropSize            = 0xc620,
		ColorMatrix1               = 0xc621,
		ColorMatrix2               = 0xc622,
		CameraCalibration1         = 0xc623,
		CameraCalibration2         = 0xc624,
		ReductionMatrix1           = 0xc625,
		ReductionMatrix2           = 0xc626,
		AnalogBalance              = 0xc627,
		AsShotNeutral              = 0xc628,
		AsShotWhiteXY              = 0xc629,
		BaselineExposure           = 0xc62a,
		BaselineNoise              = 0xc62b,
		BaselineSharpness          = 0xc62c,
		BayerGreenSplit            = 0xc62d,
		LinearResponseLimit        = 0xc62e,
		DNGCameraSerialNumber      = 0xc62f,
		DNGLensInfo                = 0xc630,
		ChromaBlurRadius           = 0xc631,
		AntiAliasStrength          = 0xc632,
		ShadowScale                = 0xc633,
		DNGPrivateData             = 0xc634,
		MakerNoteSafety            = 0xc635,
		CalibrationIlluminant1     = 0xc65a,
		CalibrationIlluminant2     = 0xc65b,
		BestQualityScale           = 0xc65c,
		AliasLayerMetadata         = 0xc660,
		OwnerName                  = 0xfde8,
		SerialNumber2              = 0xfde9,
		Lens                       = 0xfdea,
		RawFile                    = 0xfe4c,
		Converter                  = 0xfe4d,
		WhiteBalance2              = 0xfe4e,
		Exposure                   = 0xfe51,
		Shadows                    = 0xfe52,
		Brightness                 = 0xfe53,
		Contrast2                  = 0xfe54,
		Saturation2                = 0xfe55,
		Sharpness2                 = 0xfe56,
		Smoothness                 = 0xfe57,
		MoireFilter                = 0xfe58,
}ExifTag;

const local int dataFormatLength[13] = {0,1,1,2,4,8,1,1,2,4,8,4,8};

typedef enum <WORD> tagDataFormat{
	uByte = 1,
		ascString,
		uShort,
		uLong,
		uRatio,
		sByte,
		undefined,
		sShort,
		sLong,
		sRatio,
		sFloat,
		dFloat,
}DataFormat;


typedef struct tgDIRENTRY{
	ChangeColor(0);
	if(isMakerNote==1){
		CasioTag2 tagNumber;
	}else{
		ExifTag tagNumber;
	}
	DataFormat dataFormat;
	DWORD nComponent;
	DWORD offsetData;
}DIRENTRY<read=ReadDirEntry>;

string ReadDirEntry(DIRENTRY &entry){
	local char no[50];
	SPrintf(no,"Tag# = 0x%x",entry.tagNumber);
	return no;
}


typedef struct tgIFD{
	WORD nDirEntry;
	DIRENTRY dirEntry[nDirEntry]<optimize=true>;
	DWORD nextIFDoffset;
	local int i = 0;
	for(i=0;i<nDirEntry;i++){
		ChangeColor(0);
		switch(dirEntry[i].tagNumber){
			case ExifOffset:
			case InteropOffset:
				FSeek(offset + dirEntry[i].offsetData);
				struct IFD subDir;
				break;
			case 271:
				ReadBytes(CameraMake,offset + dirEntry[i].offsetData,dirEntry[i].nComponent);
				Printf("Maker: %s\n",CameraMake);
				break;
			case 272:
				ReadBytes(CameraModel,offset + dirEntry[i].offsetData,dirEntry[i].nComponent);
				Printf("Model: %s\n",CameraModel);
				break;
		}
		if((dirEntry[i].tagNumber == MakerNote) && 
			!Strncmp("CASIO COMPUTER CO.,LTD",CameraMake,22) && 
			!Strncmp("QV-R62",CameraModel,6))
		{
			FSeek(offset + dirEntry[i].offsetData);
			isMakerNote = 1;
			struct{
				char Header[6];
				struct IFD CasioIFD;
			}CasioMake;
			isMakerNote = 0;
			continue;
		}
		if(dirEntry[i].tagNumber == CasioPreviewThumbnail){
			FSeek(offset + dirEntry[i].offsetData);
			Printf("Casio Thumbnail Offset = %#Lx\n",offset + dirEntry[i].offsetData);
			BigEndian();
			local quad JpegFileSize2 = JpegFileSize;
			JpegFileOffset = offset + dirEntry[i].offsetData;
			JpegFileSize = dirEntry[i].nComponent;
			struct JPGFILE CasioMakerThumbnail;
			JpegFileSize = JpegFileSize2;
			JpegFileOffset = 0;
			if(lalign == 'I') LittleEndian();
			continue;
		}
		switch(dirEntry[i].dataFormat){
			case ascString:
			case undefined:
				if(dirEntry[i].nComponent > 4){
					FSeek(offset + dirEntry[i].offsetData);
					struct{
						uchar oneByteData[dirEntry[i].nComponent];
					}strAscii;
				}
				break;
			case uShort:
				if(dirEntry[i].nComponent > 2){
					FSeek(dirEntry[i].offsetData + offset);
					struct{
						ushort usValue[dirEntry[i].nComponent];
					}strUShort;
				}
				break;
			case uLong:
				if(dirEntry[i].nComponent > 1){
					FSeek(dirEntry[i].offsetData + offset);
					struct{
						ulong ulValue[dirEntry[i].nComponent];
					}strULong;
				}
				break;
			case uRatio:
				if(dirEntry[i].nComponent > 0){
					FSeek(dirEntry[i].offsetData  + offset);
					struct{
						struct {
							DWORD num;
							DWORD den;
						}uRValue[dirEntry[i].nComponent];
					}strURatio;
				}
				break;
			case sByte:
				if(dirEntry[i].nComponent > 4){
					FSeek(dirEntry[i].offsetData + offset);
					struct{
						char sBValue[dirEntry[i].nComponent];
					}strSByte;
				}
				break;
			case uShort:
				if(dirEntry[i].nComponent > 2){
					FSeek(dirEntry[i].offsetData + offset);
					struct{
						short sisValue[dirEntry[i].nComponent];
					}strSShort;
				}
				break;
			case sLong:
				if(dirEntry[i].nComponent > 1){
					FSeek(dirEntry[i].offsetData + offset);
					struct{
						ulong siLValue[dirEntry[i].nComponent];
					}strSLong;
				}
				break;
			case sRatio:
				if(dirEntry[i].nComponent > 0){
					FSeek(dirEntry[i].offsetData + offset);
					struct{
						struct {
							int num;
							int den;
						}siRValue[dirEntry[i].nComponent];
					}strSRatio;
				}
				break;
			case sFloat:
				if(dirEntry[i].nComponent > 1){
					FSeek(dirEntry[i].offsetData + offset);
					struct{
						float flValue[dirEntry[i].nComponent];
					}strsFloat;
				}
				break;
			case dFloat:
				if(dirEntry[i].nComponent > 0){
					FSeek(dirEntry[i].offsetData + offset);
					struct{
						double dFValue[dirEntry[i].nComponent];
					}strdFloat;
				}
				break;
		}
	}
}IFD;

typedef struct tgAPP1{
	M_ID marker;
	WORD szSection;
	char EXIF[6];
	local quad offset = FTell();
	byte align[2];
	lalign = align[0];
	if(align[0]=='I'){ LittleEndian(); }
	WORD tagMark;
	DWORD offsetFirstIFD;
	if(offsetFirstIFD!=8) 
		FSeek(offset + offsetFirstIFD);
	ChangeColor(0);
	IFD ifdMainImage;
	if(ifdMainImage.nextIFDoffset){
		FSeek(offset + ifdMainImage.nextIFDoffset);
		ChangeColor(0);
		IFD ifdThumbnailImage;
		local int i = 0;
		local int thumbOffset = 0;
		local int thumbLength = 0;
		local int compression = 10;
		for(i;i<ifdThumbnailImage.nDirEntry;i++){
			switch(ifdThumbnailImage.dirEntry[i].tagNumber){
				case Compression:
					if(align[0] == 'I')
						compression = ifdThumbnailImage.dirEntry[i].offsetData;
					else
						compression = (ifdThumbnailImage.dirEntry[i].offsetData)>>16;
					break;
				case ThumbnailOffset:
				case StripOffsets:
					if(dataFormatLength[ifdThumbnailImage.dirEntry[i].dataFormat]*ifdThumbnailImage.dirEntry[i].nComponent<4){
						if(align[0] == 'I')
							thumbOffset = ifdThumbnailImage.dirEntry[i].offsetData;
						else
							thumbOffset = (ifdThumbnailImage.dirEntry[i].offsetData)>>16;
					}else{thumbOffset = ifdThumbnailImage.dirEntry[i].offsetData;}
					break;
				case ThumbnailLength:
				case StripByteCounts:
					if(dataFormatLength[ifdThumbnailImage.dirEntry[i].dataFormat]*ifdThumbnailImage.dirEntry[i].nComponent<4){
						if(align[0] == 'I')
							thumbLength = ifdThumbnailImage.dirEntry[i].offsetData;
						else
							thumbLength = (ifdThumbnailImage.dirEntry[i].offsetData)>>16;
					}else{thumbLength = ifdThumbnailImage.dirEntry[i].offsetData;}
					break;
			}
		}
		if(thumbLength && thumbOffset){
			FSeek(offset + thumbOffset);
			Printf("Thumbnail Offset = %#Lx\n",offset + thumbOffset);
			if(compression == 6){
				BigEndian();
				local quad JpegFileSize2 = JpegFileSize;
				JpegFileOffset = thumbOffset + offset;
				JpegFileSize = thumbLength;
				struct JPGFILE thumbnail;
				JpegFileSize = JpegFileSize2;
				JpegFileOffset = 0;
				if(align[0] == 'I') LittleEndian();
			}
			else
				char imageData[thumbLength];
		}
	}
	FSeek(offset + szSection - 8);
	if(align[0]=='I'){ BigEndian(); }
}APP1;


typedef struct tagSOS{
	M_ID marker;
	WORD szSection;
	ubyte nr_comp;
	ChangeColor(0);
	struct COMPSOS{
		ubyte AC:4;
		ubyte DC:4;
	}comp[nr_comp];
	ubyte skip[3];
}SOS;

typedef struct tagUNK{
	M_ID UnknownMarker;
	WORD szSection;
	ubyte skip[szSection-2];
}UNKNOWN;

typedef struct tgCifDirEntry{
	WORD Tag;
	DWORD sData; // Data Size (Bytes)
	DWORD oData; // Data Offset
}CifDirEntry;

typedef struct tgCDir{
	ChangeColor(0);
	//Printf("off %#Lx doff %#Lx dsz %#Lx\n",cifOffset , cDirOffset ,cDirSize);
	local quad myOffset = cDirOffset;
	local DWORD S = ReadInt(myOffset + cDirSize - 4);
	FSeek(cDirOffset + S);
	//Printf("S @ %#x = %#x Ftell %#Lx",S,myOffset + cDirSize - 4,FTell());
	WORD nDirEntry;
	//Printf(" nEntry %#x\n",nDirEntry);
	ChangeColor(0);
	CifDirEntry dirEntries[nDirEntry]<optimize=false>;
	DWORD szValues; // = S
	local int i;
	for(i=0;i<nDirEntry;i++){
		//Printf("%d. Entry %#x = [ %#x  %#x %#x]\n",i,dirEntries[i].Tag,dirEntries[i].Tag & 0xC000,dirEntries[i].Tag & 0x3800,dirEntries[i].Tag & 0x07FF);
		if(!(dirEntries[i].Tag & 0xC000)){
			// Values are stored at a different location
			FSeek(myOffset + dirEntries[i].oData);
			ChangeColor(0);
			//Printf("%d size %#x offset %#x clrIdx = [%d %d]\n",i,dirEntries[i].sData,dirEntries[i].oData,colorSelect,colorId);
			switch(dirEntries[i].Tag & 0x3800){
				case 0:
					struct{
						byte bData[dirEntries[i].sData];
					}strBytes;
					break;
				case 0x0800:
					struct{
						char sData[dirEntries[i].sData];
					}strStrings;
					break;
				case 0x1000:
					struct{
						WORD wData[dirEntries[i].sData>>1];
					}str2Bytes;
					break;
				case 0x1800:
					union{
						DWORD dwData[dirEntries[i].sData>>2];
						DWORD flData[dirEntries[i].sData>>2];
					}str4Bytes;
					break;
				case 0x2800:
				case 0x3000:
					cDirOffset = dirEntries[i].oData + myOffset;
					cDirSize = dirEntries[i].sData;
					struct CDIR subDir;
					break;
				default:
					struct{
						char uData[dirEntries[i].sData];
					}strUnknown;
					break;
			}
		}
		//else value is samaller than 8 byte so it is stored in sData and oData of CifDirEntry struct
	}

}CDIR;

typedef struct tagApp0{
	M_ID marker;
	WORD szSection;
	local char LApp0Type[4];
	ReadBytes(LApp0Type,FTell(),4);
	if(!Strncmp(LApp0Type,"JFIF",4)){
		char  App0Type[5];
		short versionHigh:8;
		short versionLow:8;
		ubyte units;
		WORD Xdensity;
		WORD Ydensity;
		ubyte xThumbnail;
		ubyte yThumbnail;
		FSkip(szSection - 16);
	}else if(!Strncmp(LApp0Type,"JFXX",4)){
		char  App0Type[5];
		byte dataType;
		if(dataType == 0x10){
			local quad JpegFileSize2 = JpegFileSize;
			JpegFileOffset = FTell();
			JpegFileSize = szSection - 8;
			struct JPGFILE thumbnail;
			JpegFileSize = JpegFileSize2;
			JpegFileOffset = 0;
		}else{
			FSkip(szSection - 8);
		}
	}else if(!Strncmp(LApp0Type,"II",2) || !Strncmp(LApp0Type,"MM",2)){
		local quad cDirSize  = 0;
		local quad cDirOffset = 0;
		local quad cifOffset = FTell();
		//CIFF Header
		char ByteOrder[2];
		if(!Strncmp(ByteOrder,"II",2)) LittleEndian();
		DWORD BlockStart;
		char Signature[8];
		//Ciff Directory
		cDirOffset  = BlockStart + cifOffset;
		cDirSize    = szSection - 2 - BlockStart;
		CDIR  APP0_Ciff;
		BigEndian();
		FSeek(cifOffset + szSection - 2);
	}
	else{
		FSkip(szSection - 2);
	}
}APP0;

typedef struct tagDHT{
	M_ID marker;
	WORD szSection;
	local WORD huffsz = szSection - 2;
	while(huffsz > 0){
		ChangeColor(0);
		struct Huffmann_Table{
			ubyte htInfo;
			ubyte length[16];
			local int sumLen = 0;
			local int i = 0;
			for(i;i<16;i++){
				sumLen += length[i];
			}
			ubyte HTV[sumLen];
		}huff_table;
		huffsz -= sizeof(huff_table);
	}
}DHT;

typedef struct tagDQT{
	M_ID marker;
	WORD szSection;
	local WORD qtsz = szSection - 2;
	while(qtsz > 0){
		ChangeColor(0);
		struct QuanTable{
			ubyte qtInfo;
			byte qTable[64];
		}qtable;
		qtsz -= sizeof(qtable);
	}
}DQT;
typedef struct tgSOF0{
	M_ID marker;
	WORD szSection;
	ubyte precision;
	WORD Y_image;
	WORD X_image;
	ubyte nr_comp;
	ChangeColor(0);
	struct COMPS{
		ubyte compId;
		ubyte Horz:4;
		ubyte Vert:4;
		ubyte compNr;
	}comp[nr_comp];
}SOF0;


typedef struct tagCOMMENT{
	M_ID CommentMarker;
	WORD szSection;
	char comment[szSection-2];
	

	local char comments[szSection-1] = {0};
	local int i = 0;
	Memcpy(comments,comment,szSection-2);
	for(i=0;i<szSection-1;i++){
		if(comments[i]==0) comments[i] = 'x';
	}
	comments[szSection-2] = 0;
	Printf("\nCOMMENT :\n%s\n\n",comments);

}COMMENT<read=ReadComment>;

typedef struct tagAPP12{
	M_ID app12Marker;
	WORD szSection;
	char infoData[szSection-2];
	
	local char comments[szSection-1] = {0};
	local int i = 0;
	Memcpy(comments,infoData,szSection-2);
	for(i=0;i<szSection-1;i++){
		if(comments[i]==0) comments[i] = '?';
	}
	comments[szSection-2] = 0;
	Printf("\nMaker Comment,(Char 0 is replaced by ?) :\n%s\n\n",comments);

}APP12<read=ReadApp12>;

string ReadComment( COMMENT &com )
{
	return com.comment;
}

string ReadApp12( APP12 &com )
{
	return com.infoData;
}

JpegFileSize = FileSize();

SetBackColor(jetMap[0]);
typedef struct tgJPGFile{
	local WORD NextMarker;
	local WORD sectionSize;
	local quad fpos = FTell();
	local quad fpos2;
	local byte bEOI = 0;
	while(fpos - JpegFileOffset < JpegFileSize && !bEOI){
		fpos2 = fpos;
		do{
			//Try forward search
			NextMarker  = ReadUShort(fpos);
			FSeek(++fpos);
			if(fpos - fpos2 >= 6){
				Printf("Can not find valid marker(Forward Search)\n");
				Exit(0);
			}
		}while(NextMarker == 0xFFFF);
		if((NextMarker & 0xFF00) != 0xFF00){
			fpos = fpos2;
			do{
				NextMarker  = ReadUShort(fpos);
				FSeek(--fpos);
				if(fpos2 - fpos >= 3){
					Printf("Can not find valid marker(Backward Search)\n");
					Exit(0);
				}
			}while((NextMarker & 0xFF00) != 0xFF00);
			FSeek(++fpos);
		}else{
			FSeek(--fpos);
		}
		sectionSize = ReadUShort(fpos+2);
		switch(NextMarker){
		case M_SOI:
			M_ID SOIMarker;
			Printf("Start of Image Marker\n");
			break;
		case M_SOS:
			SOS  scanStart;
			Printf("Start of Scan Marker\n");
			NextMarker = ReadUShort(JpegFileSize - 2 + JpegFileOffset);
			fpos2 = 0;
			while(NextMarker != M_EOI){
				NextMarker = ReadUShort(JpegFileSize - 2 + JpegFileOffset - (++fpos2));
			} 
			char scanData[JpegFileSize - FTell() - 2 + JpegFileOffset - fpos2];
			ChangeColor(1);
			M_ID EOIMarker;
			Printf("End of File Image\n");
			if(fpos2) char unknownPadding[fpos2];
			bEOI = 1;
			break;
		case M_APP0:
			APP0 app0;
			break;
		case M_DHT:
			DHT dht;
			break;
		case M_DQT:
			DQT dqt;
			break;
		case M_SOF0:
			SOF0 sof0;
			break;
		case M_APP1:
			APP1 app1;
			break;
		case M_COMM:
			COMMENT comment;
			break;
		case M_APP12:
			APP12 app12;
			break;
		default:
			UNKNOWN unknownSection;
			break;
		}
		fpos = FTell();
		ChangeColor(!bEOI);
	}
}JPGFILE;

JPGFILE jpgfile;